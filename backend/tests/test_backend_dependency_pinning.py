from __future__ import annotations

import re
from pathlib import Path


def _repo_root() -> Path:
    return Path(__file__).resolve().parents[2]


_REQ_LINE_RE = re.compile(r"^(?P<name>[A-Za-z0-9_.-]+)(?:\[[^\]]+\])?==(?P<version>[^\s;]+)")


def _read_requirements_file(path: Path) -> list[str]:
    lines: list[str] = []
    for raw in path.read_text(encoding="utf-8").splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        if line.startswith("-"):
            # Options like -r, --index-url, --extra-index-url, etc.
            continue
        lines.append(line)
    return lines


def _parse_pinned_requirements(lines: list[str]) -> dict[str, str]:
    pinned: dict[str, str] = {}
    for line in lines:
        match = _REQ_LINE_RE.match(line)
        assert match, f"Unpinned or unsupported requirement line: {line!r}"
        pinned[match.group("name").lower()] = match.group("version")
    return pinned


def test_backend_requirements_in_exists_and_is_fully_pinned() -> None:
    req_in = _repo_root() / "backend" / "requirements.in"
    assert req_in.exists(), "Missing backend/requirements.in"

    lines = _read_requirements_file(req_in)
    assert lines, "backend/requirements.in must not be empty"
    _parse_pinned_requirements(lines)


def test_backend_requirements_txt_is_generated_and_covers_transitives() -> None:
    req_in = _repo_root() / "backend" / "requirements.in"
    req_txt = _repo_root() / "backend" / "requirements.txt"
    assert req_txt.exists(), "Missing backend/requirements.txt"

    header = req_txt.read_text(encoding="utf-8").splitlines()[:5]
    header_text = "\n".join(header).lower()
    assert "autogenerated" in header_text or "generated" in header_text

    pinned_in = _parse_pinned_requirements(_read_requirements_file(req_in))
    pinned_txt = _parse_pinned_requirements(_read_requirements_file(req_txt))

    for name, version in pinned_in.items():
        assert name in pinned_txt, f"{name} from requirements.in not found in requirements.txt"
        assert pinned_txt[name] == version, f"{name} version mismatch between .in and .txt"

    assert len(pinned_txt) > len(pinned_in), "requirements.txt must include transitive dependencies"


def test_python_tooling_targets_python_314() -> None:
    pyproject = _repo_root() / "backend" / "pyproject.toml"
    content = pyproject.read_text(encoding="utf-8")

    assert "target-version = ['py314']" in content or 'target-version = ["py314"]' in content
    assert 'target-version = "py314"' in content
    assert 'python_version = "3.14"' in content
