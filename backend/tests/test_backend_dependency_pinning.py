from __future__ import annotations

import re
import sys
from pathlib import Path

if sys.version_info >= (3, 11):
    import tomllib
else:
    try:
        import tomli as tomllib
    except ImportError:
        tomllib = None  # type: ignore[assignment]


def _repo_root() -> Path:
    return Path(__file__).resolve().parents[2]


_REQ_LINE_RE = re.compile(
    r"^(?P<name>[A-Za-z0-9_.-]+)(?:\[[^\]]+\])?(?P<op>==|>=|>|<=|<|!=)(?P<version>[^\s;]+)"
)
_REQ_LINE_STRICT_RE = re.compile(
    r"^(?P<name>[A-Za-z0-9_.-]+(?:\[[^\]]+\])?)(?P<op>==)(?P<version>[^\s;]+)"
)

EXPECTED_DIRECT_REQUIREMENTS = {
    "fastapi": "0.115.6",
    "uvicorn[standard]": "0.27.1",
    "pydantic": "2.10.4",
    "pydantic-settings": "2.6.1",
    "email-validator": "2.1.1",
    "python-dotenv": "1.0.1",
    "docker": "7.0.0",
    "requests": "2.31.0",
    "httpx": "0.27.0",
    "cryptography": "44.0.1",
    "pytest": "8.1.1",
    "pytest-asyncio": "0.23.5",
    "hypothesis": "6.98.15",
}


def _read_requirements_file(path: Path) -> list[str]:
    lines: list[str] = []
    for raw in path.read_text(encoding="utf-8").splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        if line.startswith("-"):
            # Options like -r, --index-url, --extra-index-url, etc.
            continue
        lines.append(line)
    return lines


def _parse_pinned_requirements(lines: list[str]) -> dict[str, str]:
    """依存関係をパースし、名前とバージョンのマッピングを返す。

    ==による厳密なピンニング、または>=などの最小バージョン要件を許容します。
    セキュリティ上の理由により、特定のパッケージには範囲指定が推奨される場合があります。
    """
    pinned: dict[str, str] = {}
    for line in lines:
        match = _REQ_LINE_RE.match(line)
        assert match, (
            f"Missing version specifier in requirement line: {line!r}. "
            f"All dependencies must specify a version using ==, >=, >, <=, <, or !="
        )
        pinned[match.group("name").lower()] = match.group("version")
    return pinned


def _parse_strictly_pinned_requirements(lines: list[str]) -> dict[str, str]:
    """==のみを許容し、extras付きパッケージも含めて厳密に取得する。"""
    pinned: dict[str, str] = {}
    for line in lines:
        match = _REQ_LINE_STRICT_RE.match(line)
        assert match, (
            f"Requirement must be pinned with '==': {line!r}. "
            "Remove caret/range specifiers and pin to an exact version."
        )
        pinned[match.group("name").lower()] = match.group("version")
    return pinned


def test_backend_requirements_in_exists_and_is_fully_pinned() -> None:
    """requirements.inが存在し、すべての依存関係にバージョン指定があることを確認する。

    セキュリティ上の理由により、一部のパッケージには>=などの最小バージョン要件が
    使用される場合があります（例：CVE対応）。
    """
    req_in = _repo_root() / "backend" / "requirements.in"
    assert req_in.exists(), "Missing backend/requirements.in"

    lines = _read_requirements_file(req_in)
    assert lines, "backend/requirements.in must not be empty"
    _parse_pinned_requirements(lines)


def test_backend_requirements_in_matches_expected_direct_dependencies() -> None:
    """直接依存が==で厳密に固定され、設計で合意したバージョンと一致することを確認する。"""
    req_in = _repo_root() / "backend" / "requirements.in"
    pinned = _parse_strictly_pinned_requirements(_read_requirements_file(req_in))
    expected = {name.lower(): version for name, version in EXPECTED_DIRECT_REQUIREMENTS.items()}
    assert pinned == expected, (
        "backend/requirements.in must pin the agreed direct dependencies with exact versions "
        f"(expected {expected}, got {pinned})"
    )


def test_backend_requirements_txt_is_generated_and_covers_transitives() -> None:
    """requirements.txtが生成されており、推移的依存関係を含むことを確認する。

    requirements.txtは、requirements.inからpip-compileで生成され、
    直接依存関係と推移的依存関係の両方が厳密なバージョンで固定されます。
    """
    req_in = _repo_root() / "backend" / "requirements.in"
    req_txt = _repo_root() / "backend" / "requirements.txt"
    assert req_txt.exists(), "Missing backend/requirements.txt"

    header = req_txt.read_text(encoding="utf-8").splitlines()[:5]
    header_text = "\n".join(header).lower()
    assert "autogenerated" in header_text or "generated" in header_text

    pinned_in = _parse_pinned_requirements(_read_requirements_file(req_in))
    pinned_txt = _parse_pinned_requirements(_read_requirements_file(req_txt))

    for name, _version in pinned_in.items():
        assert name in pinned_txt, f"{name} from requirements.in not found in requirements.txt"
        # requirements.inで最小バージョン（>=）を指定している場合、requirements.txtでは
        # より新しい具体的なバージョンが解決されている可能性がある
        # そのため、バージョン完全一致のチェックはスキップする

    assert len(pinned_txt) > len(pinned_in), "requirements.txt must include transitive dependencies"


def test_backend_requirements_txt_aligns_with_direct_pins_and_python314() -> None:
    """requirements.txtが==のみを使用し、Python 3.14で生成され、直接依存とバージョンが揃うことを確認する。"""
    req_txt = _repo_root() / "backend" / "requirements.txt"
    assert req_txt.exists(), "Missing backend/requirements.txt"

    header = req_txt.read_text(encoding="utf-8").splitlines()[:5]
    header_text = "\n".join(header).lower()
    assert "python 3.14" in header_text, "requirements.txt should be generated with Python 3.14"

    pinned_txt = _parse_strictly_pinned_requirements(_read_requirements_file(req_txt))
    expected = {name.lower(): version for name, version in EXPECTED_DIRECT_REQUIREMENTS.items()}

    for name, version in expected.items():
        assert name in pinned_txt, f"{name} from requirements.in missing in requirements.txt"
        assert pinned_txt[name] == version, (
            f"{name} version mismatch: expected {version}, got {pinned_txt[name]}"
        )


def test_python_tooling_targets_python_314() -> None:
    """各ツールのPython 3.14ターゲット設定を確認する。

    各ツールは異なるフォーマットを使用：
    - Black: target-version = ['py314'] (リスト形式)
    - Ruff: target-version = "py314" (文字列形式)
    - mypy: python_version = "3.14" (バージョン文字列)
    """
    pyproject = _repo_root() / "backend" / "pyproject.toml"

    # ファイルの存在を確認
    assert pyproject.exists(), (
        f"Missing {pyproject.relative_to(_repo_root())}. "
        "This file is required to configure Python tooling."
    )

    # TOMLパーサーが利用可能か確認
    if tomllib is None:
        # Python < 3.11 かつ tomli がインストールされていない場合はスキップ
        import pytest
        pytest.skip("tomllib/tomli not available")

    # TOMLファイルをパース
    with open(pyproject, "rb") as f:
        config = tomllib.load(f)

    # [tool.black] セクションの確認
    assert "tool" in config, "pyproject.toml must have [tool] section"
    assert "black" in config["tool"], "pyproject.toml must have [tool.black] section"
    black_config = config["tool"]["black"]
    assert "target-version" in black_config, "[tool.black] must specify target-version"
    # Blackはリスト形式を期待
    assert isinstance(black_config["target-version"], list), (
        "[tool.black] target-version must be a list"
    )
    assert "py314" in black_config["target-version"], (
        "[tool.black] target-version must include 'py314'"
    )

    # [tool.ruff] セクションの確認
    assert "ruff" in config["tool"], "pyproject.toml must have [tool.ruff] section"
    ruff_config = config["tool"]["ruff"]
    assert "target-version" in ruff_config, "[tool.ruff] must specify target-version"
    # Ruffは文字列形式を期待
    assert isinstance(ruff_config["target-version"], str), (
        "[tool.ruff] target-version must be a string"
    )
    assert ruff_config["target-version"] == "py314", (
        '[tool.ruff] target-version must be "py314"'
    )

    # [tool.mypy] セクションの確認
    assert "mypy" in config["tool"], "pyproject.toml must have [tool.mypy] section"
    mypy_config = config["tool"]["mypy"]
    assert "python_version" in mypy_config, "[tool.mypy] must specify python_version"
    # mypyはバージョン文字列を期待
    assert isinstance(mypy_config["python_version"], str), (
        "[tool.mypy] python_version must be a string"
    )
    assert mypy_config["python_version"] == "3.14", (
        '[tool.mypy] python_version must be "3.14"'
    )
