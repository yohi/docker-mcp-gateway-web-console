# Requirements Document

## Introduction
本機能では、MCP Catalog の利用を拡張し、OAuth が必要なサーバー接続、動的なサーバー追加・実行、イメージ署名検証、外部/E2B ゲートウェイ接続を安全かつ一貫した UI/バックエンド体験として提供する。これにより、開発者は秘密情報を安全に扱いつつ、カタログからの導入・検証をスムーズに行える。

## Requirements

### Requirement 1: OAuth 認可フロー管理
**Objective:** 認可が必要な MCP サーバーを安全に接続したいオペレータとして、UI から OAuth フローを完結させ、トークンを安全に保管したい。

#### Acceptance Criteria
1. WHEN ユーザーが対象 MCP サーバーの OAuth 接続開始を要求する THEN バックエンド SHALL 乱数 state と PKCE コードを生成し、カタログが指定する必須スコープを付与した認可 URL を 200 で返却する。
2. IF OAuth コールバックで state が一致しない THEN バックエンド SHALL 401 を返却し「state 不一致のため再認可を実施してください」とメッセージ表示し、トークン/コードを含まない相関 ID 付きログを残す。
3. IF トークン交換時にプロバイダが 4xx（無効 code / 拒否）を返す THEN バックエンド SHALL 400 を返却し再認可を促すユーザ向けメッセージを返し、秘密情報を含まない警告ログを記録する。
4. WHEN トークン交換で 5xx またはタイムアウトが発生する THEN バックエンド SHALL 1s→2s→4s の指数バックオフで最大 3 回リトライし、失敗時は 502 と「プロバイダ障害。時間を置いて再試行してください」のメッセージを返し、相関 ID 付きで例外を記録する。
5. WHEN アクセストークン取得が成功する THEN バックエンド SHALL アクセス/リフレッシュトークン・有効期限・スコープを Bitwarden `bw://mcp-oauth/<server>` または暗号化ストレージに保存し、UUID v4 の `credential_key` を生成して (a) カタログ DB の対象サーバー行の `credential_key` フィールド、(b) 相関 ID 付き監査ログに記録し、キーはトークン復号・セッション復旧・ローテーション参照にのみ使用し、閲覧は管理者ロールに限定し、トークン失効または削除から 30 日後に自動削除する（例: `credential_key=550e8400-e29b-41d4-a716-446655440000` を DB に保存し、Bitwarden のアイテム ID と 1:1 で対応付けて復号時に参照する）。
6. IF リフレッシュトークンが発行される THEN バックエンド SHALL 有効期限が 15 分未満になった時点で自動リフレッシュを行い、成功時に新しいトークンと有効期限・スコープを保存して旧トークンを破棄する。
7. WHEN リフレッシュが invalid_grant/invalid_token で失敗する THEN バックエンド SHALL 保存済みトークンを削除しステータスを「要再認可」に更新しつつ 401 を返却し、ユーザに再認可を案内する。
8. WHEN リフレッシュが 5xx/タイムアウトで失敗する THEN バックエンド SHALL 2s→4s のバックオフで最大 2 回リトライし、失敗時は 503 を返却し、現在のトークンが有効期限切れになるまで現状の状態を維持する。
9. WHERE カタログメタデータが要求するスコープが定義されているとき THEN バックエンド SHALL 要求スコープを許可リストで検証し、未許可スコープが含まれる場合は 400 を返却し既存トークンを変更しない。
10. WHEN 管理者が許可スコープを更新する THEN バックエンド SHALL 保存済みトークンを無効化しステータスを「要再認可」に変更し、新スコープでの再認可を必須にする。
11. IF 非管理者がスコープ変更を試行する THEN バックエンド SHALL 403 を返却しスコープおよび保存トークンを一切変更しない。

### Requirement 2: Dynamic MCP サーバー管理
**Objective:** 会話中に MCP サーバーを探索・追加・設定変更・実行したいオペレータとして、セッション単位で動的にサーバーを管理したい。

#### Acceptance Criteria
1. WHEN ユーザーが検索条件を送信する THEN バックエンド SHALL カタログから名前・説明・必要シークレットを含む結果リストを返却する。
2. WHEN ユーザーがサーバー追加を要求する THEN バックエンド SHALL セッションごとにリソース制限付きの専用ゲートウェイコンテナ（cgroup CPU 0.5core/メモリ512MB、ネットワーク/ファイルシステム名前空間分離）を起動し、gRPC over mTLS（同一ホストでは Unix ドメインソケットを優先）で指示を送る論理セッションを生成し、データプレーンを mTLS で暗号化し、アイドル 30 分で GC・セッション終了で停止・異常終了時は 1 回再起動、Prometheus メトリクス/構造化ログ/`/health` ライフゲートを公開する。デプロイ時にコスト優先モードを有効化した場合のみプール運用を許可し、その際も資格情報と設定は論理スコープで完全分離し共有メモリを禁止する。
3. IF ユーザーが設定変更を送信する THEN バックエンド SHALL 変更後の設定をセッションストアに保存し結果を返却する。
4. WHEN ユーザーが mcp-exec を要求する THEN バックエンド SHALL 対象ツールを実行し、デフォルト最大実行時間 `max_run_seconds=60`（設定で 10〜300 の範囲に変更可）を超えた場合はプロセスを強制終了し部分出力を返却し `timeout=true` と特別な `exit_code=124` を返し、stdout/stderr 合算で `output_bytes_limit=128000`（設定で 32KB〜1MB）を超えた場合は末尾を切り詰め `truncated=true` と残サイズを返す。同期モードでは `output`, `exit_code`, `started_at`, `finished_at`, `timeout`, `truncated` を返却する。非同期モード指定時はジョブを作成し `job_id`, `queued_at`, `started_at (null 可能)`, `status in {queued,running,succeeded,failed,timeout,truncated}` を返し、クライアントは `/jobs/{job_id}/status` のポーリングまたは WebSocket/ログストリーム（チャンク最大 8KB、保持 24h）で出力を取得し、完了レスポンスには同期モードと同じフィールドに加え `async=true` を含める。
5. WHEN ユーザーがサーバー削除またはセッション終了を行う THEN バックエンド SHALL 該当サーバーのプロセスと一時ファイルを停止・削除する。

### Requirement 3: MCP イメージ署名検証
**Objective:** 署名付きイメージのみを許可したいセキュリティ担当として、カタログ導入時に署名検証を必須化し、失敗時のハンドリングを明確にしたい。

#### Acceptance Criteria
1. IF verify_signatures が有効 THEN バックエンド SHALL `docker mcp gateway run` 実行時に署名検証オプションを必須で付与し、署名なしイメージはデフォルトで拒否（HTTP 422 / CLI exit 78、「署名未検証のためデプロイを中断しました」）とし、`permit_unsigned` 明示指定または許可リストに登録されたイメージのみ例外的に許可する。`mode=enforcement` では失敗時に即時中断し上記エラーを返す。`mode=audit-only` では処理を継続しつつ警告ログとメトリクスを出力しレスポンスに「署名未検証（監査モード）」を含める。グレース期間を設定可能（例: 14 日）とし、その期間は audit-only を既定、期限後は自動で enforcement に切り替え、切替時にメトリクス/ログで告知する。
2. WHEN 署名検証が失敗する THEN バックエンド SHALL RSA-PSS(SHA-256) を第一優先アルゴリズムとし、許可アルゴリズムを {RSA-PSS(SHA-256), ECDSA(SHA-256)} に限定し、カタログサーバーの TLS 保護された JWKS/PEM エンドポイントから公開鍵を取得（キャッシュ 6h）または管理者アップロードのローカルトラストストアを使用し、PKI チェーンを OS/内蔵ルート CA で検証し中間証明書を連結、CRL/OCSP で失効確認する。鍵ローテーションは 30 日周期、7 日のデュアルサイン猶予期間を設け自動フェッチ＆検証、緊急ローテーション時は管理者が新鍵をアップロードし即時有効化する。検証失敗時は処理を中断し HTTP 422 / exit 78 を返し、エラー payload に `error_code` ∈ {`algo_mismatch`,`invalid_signature`,`key_not_found`,`key_expired_or_revoked`,`pki_chain_invalid`} と `message`（例:「署名検証に失敗しました: key_not_found — 公開鍵を取得できません。カタログの鍵配布設定を確認してください。」）および `remediation`（例:「鍵の配布エンドポイントと証明書を更新し、再度デプロイを実行してください。」）を含める。
3. WHERE UI で署名検証トグルを無効化したとき THEN フロントエンド SHALL 保存前にリスク警告ダイアログを表示する。
4. WHILE verify_signatures が有効 THE バックエンド SHALL バックエンドアプリケーションログおよび監査ログ（INFO）に限り署名検証の成功/失敗とカテゴリ（`signature_mismatch`,`certificate_invalid`,`key_not_found`,`key_expired_or_revoked`,`algo_mismatch`,`pki_chain_invalid`）のみを記録し、トークン/リフレッシュトークン/パスワード/秘密鍵/セッションID/PII/鍵マテリアル/生データを一切出力せず、ユーザ向けログ/UI には成功/失敗の要約のみ表示する。DEBUG ログでも秘密情報は記録禁止とし、診断メタデータ（相関ID、鍵IDハッシュ、アルゴリズム名、検証時間）に限定する。

### Requirement 4: 外部/E2B ゲートウェイ接続
**Objective:** E2B サンドボックスなど外部ゲートウェイを利用したいユーザーとして、URL/トークンを安全に登録し接続性を検証したい。

#### Acceptance Criteria
1. WHEN ユーザーが外部ゲートウェイの URL とトークンを保存する THEN バックエンド SHALL URL スキーマ検証に続け、許可リスト（エントリ必須フィールド: `id`, `type ∈ {domain,pattern,service}`, `value`, `createdBy`, `createdAt`, `enabled`）でドメイン/パスパターン/サービス識別子（例: E2B 既知サービス）を照合し、グローバル許可リスト（プラットフォーム管理者管理）を優先し、組織別上書きリスト（管理 UI/API で設定）をマージして適用し、ミス時/未登録時は拒否し 400 と「許可リスト未登録のゲートウェイ URL です」を返す。リストはバージョン管理され、監査ログに変更履歴を記録し、設定サービス/API 経由でホットリロード（再デプロイ不要）し、常に最新アクティブ版で検証する。検証順序は schema → whitelist → トークン保存で、拒否時は理由と相関 ID を WARN ログに残す（秘密情報は出力しない）。
2. WHEN 接続テストを実行する THEN バックエンド SHALL `/healthcheck` を (a) URL/トークン保存直後に自動実行し、(b) ユーザーが「接続テスト」ボタンを押したときに手動実行し、(c) 稼働中は 5 分間隔で定期実行し、最大待機時間 `healthcheck_timeout_seconds=15`（設定 10〜30 秒）で 1s→2s→4s の指数バックオフで最大 3 回リトライし、P50/P95/P99 のレイテンシを計測して返却する。失敗時は最終エラーと計測済みメトリクスを返し、成功時は最新のステータスとレイテンシ統計をレスポンスとメトリクスに記録する。
3. IF 接続テストが成功する THEN フロントエンド SHALL 「接続成功」ステータスを表示し外部モードを有効化する。
4. IF 接続テストが失敗する THEN フロントエンド SHALL エラー理由を表示し外部モードを無効化のまま保持する。
